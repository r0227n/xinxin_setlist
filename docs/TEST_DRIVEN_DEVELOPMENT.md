# テスト駆動開発（TDD）実践ガイド

## 本文書の目的

**10分でTDDの核心を理解し、今日から実践できる**ガイドです。テストを先に書くことで、より良い設計と信頼性の高いコードを効率的に開発できます。

## 核心原則：Red-Green-Refactor

**「失敗テスト作成（Red） → 最小実装（Green） → 設計改善（Refactor）」**

### 30%テストとは？

最小限のテストケースから始めるアプローチ。完璧を求めず、まず動くものを作ることが重要です。

## 初学者向けクイックスタート（今すぐ試せる）

### 最初のTDDサイクル（10分）

```javascript
// 1. Red：失敗テストを書く（5分）
test('数値を2倍にする', () => {
  expect(double(5)).toBe(10)
})
// → double関数が存在しないので失敗

// 2. Green：最小実装（3分）
function double(n) {
  return 10 // ハードコードでOK
}
// → テスト成功

// 3. Refactor：一般化（2分）
function double(n) {
  return n * 2 // 正しい実装に改善
}
```

## なぜテスト駆動開発が必要なのか？

### 問題：従来の「実装優先」アプローチ

```mermaid
flowchart LR
    A["実装を先に書く"] --> B["どんなテストを書けばいいかわからない"]
    B --> C["テスト作成の停滞"]
    C --> D["結果的に低品質なコード"]

    style A fill:#ffbaba
    style D fill:#ffbaba
```

### 解決：TDD的「テスト優先」アプローチ

| TDD原則                    | 開発での実践          | 即座のメリット     |
| -------------------------- | --------------------- | ------------------ |
| **小さなステップ**         | 1つの振る舞いから開始 | 今日から実行可能   |
| **テスト駆動**             | 失敗テストを先に定義  | 明確な成功基準     |
| **継続的リファクタリング** | 安全な設計改善        | 恐怖なく変更できる |

## 1. TDD的開発の3フェーズ：Red-Green-Refactor

### 基本サイクルの可視化

```mermaid
stateDiagram-v2
    [*] --> Red: "1. 失敗テスト作成（30%）"

    state Red {
        [*] --> TestCreation
        TestCreation --> [*]: "理想的な使い方を定義"
        note right of TestCreation
            テストが書けるまで実装しない<br/>
            コンパイルエラーは問題ない<br/>
            5分以内での作成を目指す
        end note
    }

    Red --> Green: "2. 最小実装"

    state Green {
        [*] --> MinimalImpl
        MinimalImpl --> [*]: "テスト成功まで"
        note right of MinimalImpl
            まずはテストを通すことに集中<br/>
            ハードコードも許容される<br/>
            美しさより動作を優先する
        end note
    }

    Green --> Refactor: "3. 設計改善"

    state Refactor {
        [*] --> DuplicationRemoval
        DuplicationRemoval --> DesignImprovement
        DesignImprovement --> [*]: "品質基準達成"
        note right of DesignImprovement
            テストは変更しない<br/>
            重複を排除する<br/>
            自信を持って変更する
        end note
    }

    Refactor --> Red: "次のテストへ"
    Refactor --> [*]: "機能完成"
```

### 各フェーズの実践方法

#### 🔴 Red（失敗テスト）：理想的な使い方の定義

**実践例1：電卓機能の30%テスト**

```typescript
// 30%テスト：最小限の期待値定義
describe('Calculator', () => {
  it('2つの数を足し算できる', () => {
    const calculator = new Calculator()
    const result = calculator.add(2, 3)
    expect(result).toBe(5)
  })
})

// この時点でCalculatorクラスは存在しない
// コンパイルエラーは期待通りの「Red」状態
```

**実践例2：ユーザー認証の30%テスト**

```typescript
// 30%テスト：基本的な成功ケースのみ
describe('UserAuth', () => {
  it('正しい認証情報でログイン成功', () => {
    const auth = new UserAuth()
    const result = auth.login('user@example.com', 'password123')
    expect(result.success).toBe(true)
  })
})

// エラーケースやバリデーションは次のサイクルで追加
```

**30%テスト作成の判定基準**

- [ ] 1つの振る舞いを明確に表現できている
- [ ] 実装が存在しなくてもテストの意図が理解できる
- [ ] 5分以内で記述可能な最小限の期待値

### F.I.R.S.T.原則：良いテストの基準

- **F**ast：高速実行（0.1秒以内）
- **I**ndependent：独立性（他のテストに依存しない）
- **R**epeatable：再現性（何度でも同じ結果）
- **S**elf-validating：自己検証（成功/失敗が明確）
- **T**imely：適時性（実装前に書く）

#### 🟢 Green（最小実装）：テスト成功のための最短経路

**検証可能な実装基準**

```yaml
# 最小実装品質のユニットテスト（5分で実施）
implementation_check:
  functionality:
    - [ ] テストが緑になっている
    - [ ] コンパイルエラーが解消されている
    - [ ] 意図した振る舞いを実現している

  simplicity:
    - [ ] 最も簡単な実装を選択している
    - [ ] 不要な複雑さを含んでいない
    - [ ] 必要に応じてハードコードを使用している

# 成功例：✅ テスト通過、✅ 最小実装、✅ 素早い完了
```

**実装戦略の選択**

```mermaid
flowchart TD
    A{"実装の複雑さ"} --> B["Obvious: 明白な実装"]
    A --> C["Fake It: 仮実装"]
    A --> D["Triangulation: 三角測量"]

    B --> E["すぐに正しい実装"]
    C --> F["固定値から段階的一般化"]
    D --> G["複数テストから抽象化"]

    E --> H["次のテストへ"]
    F --> I["リファクタリングで一般化"]
    G --> J["パターン発見後一般化"]

    style C fill:#ffffbf
    style F fill:#ffffbf
```

#### 🔵 Refactor（設計改善）：安全な品質向上

**改善の実行順序**

```mermaid
flowchart TD
    A{"発見された問題"} --> B["Critical: テストの重複"]
    A --> C["Important: 設計の改善"]
    A --> D["Nice: 命名の最適化"]

    B --> E["即座に修正（必須）"]
    C --> F["次サイクルで改善"]
    D --> G["時間があれば対応"]

    E --> H["テスト実行で安全確認"]
    F --> I["設計品質向上"]
    G --> J["可読性向上"]

    style B fill:#ffbaba
    style C fill:#ffffbf
    style D fill:#baffba
```

## 2. 効果的なTDD実践プロセス

### 初学者と実践者の役割分担

| 役割                 | 初学者のアプローチ       | 実践者のアプローチ       |
| -------------------- | ------------------------ | ------------------------ |
| **Redフェーズ**      | 簡単な成功ケースから開始 | エッジケースも含めて設計 |
| **Greenフェーズ**    | Fake Itで確実に成功体験  | 状況に応じて戦略選択     |
| **Refactorフェーズ** | 明らかな重複のみ除去     | 設計パターンを積極活用   |

### 段階的TDD習得フレームワーク

```mermaid
sequenceDiagram
    participant Beginner as "初学者"
    participant Code as "コード"
    participant Expert as "実践者"
    participant Quality as "品質システム"

    Note over Beginner,Quality: "TDD習得サイクル"
    Beginner->>Code: "簡単なテスト作成"
    Expert->>Code: "設計レビュー"
    Expert-->>Beginner: "Critical: 基本原則の指摘"
    Beginner->>Code: "テスト改善"

    Beginner->>Code: "Fake It実装"
    Expert-->>Beginner: "Important: 実装戦略の提案"
    Beginner->>Code: "より良い実装"

    Expert->>Code: "リファクタリング指導"
    Expert-->>Beginner: "Nice: 設計パターンの紹介"
    Beginner->>Code: "設計改善"

    Quality->>Code: "最終品質確認"
    Quality-->>Beginner: "習得度評価"
```

### 構造化TDD基準

#### 🔴 高優先度：テスト作成能力の確保

**検証項目（400文字以内でチェック）**

| チェック項目       | 合格基準            | 失敗時の対応           |
| ------------------ | ------------------- | ---------------------- |
| **テストの明確性** | 1つの振る舞いに集中 | テストを分割して再作成 |
| **実装独立性**     | 実装なしで理解可能  | テストの表現を改善     |
| **失敗確認**       | 期待通りに失敗する  | 実装がないことを確認   |

#### 🟡 中優先度：実装品質の向上

**改善の観点**

```yaml
implementation_improvement:
  strategy:
    - [ ] 適切な実装戦略を選択している
    - [ ] 最小限の変更でテストを通している
    - [ ] 設計の意図が明確に表現されている

  quality:
    - [ ] コードの可読性が高い
    - [ ] 責任が適切に分離されている
    - [ ] 将来の拡張性を考慮している
```

#### 🟢 低優先度：開発体験の最適化

**最適化要素**

| 改善項目                 | 実施基準           | 自動化可能性          |
| ------------------------ | ------------------ | --------------------- |
| **テスト実行速度**       | 0.1秒以内/テスト   | ✅ 自動測定可能       |
| **命名の一貫性**         | チーム規約を遵守   | ⚠️ リンターで設定可能 |
| **リファクタリング頻度** | 3回目のRed前に実施 | ⚠️ 人間の判断が必要   |

## 3. 継続的TDD改善とメトリクス

### TDD品質の定量評価

```mermaid
quadrantChart
    title "TDD実践品質評価マトリクス"
    x-axis "低速度" --> "高速度"
    y-axis "低保守性" --> "高保守性"
    quadrant-1 "TDD見直し必要"
    quadrant-2 "速度改善必要"
    quadrant-3 "保守性改善必要"
    quadrant-4 "理想的TDD"

    "初心者実践": [0.4, 0.3]
    "基本習得": [0.6, 0.5]
    "実践者レベル": [0.7, 0.7]
    "エキスパート": [0.9, 0.8]
```

### TDD的開発改善のKPI

| メトリクス               | 測定方法               | 目標値    | 達成時のアクション       |
| ------------------------ | ---------------------- | --------- | ------------------------ |
| **サイクル速度**         | Red→Green→Refactor時間 | 10分以内  | より複雑な機能に挑戦する |
| **テスト品質**           | F.I.R.S.T.原則の遵守率 | 95%以上   | チーム標準として展開する |
| **リファクタリング頻度** | Green後の改善実施率    | 80%以上   | 設計パターンを学習する   |
| **習得速度**             | 基本サイクル完了まで   | 1週間以内 | 実プロジェクトに適用する |

## 4. 今すぐ始められるアクションプラン

### 段階別実践ステップ

#### 💡 今日（30分）：TDD開発を体験

**初学者向け：**

- [ ] 簡単な機能（足し算など）で1つのテストを作成する
- [ ] Red → Green → Refactorを1回完了する
- [ ] 各フェーズの時間を測定する（Red: 5分、Green: 10分、Refactor: 15分）

**実践者向け：**

- [ ] より複雑な機能でTDDサイクルを実践する
- [ ] 複数の実装戦略（Fake It、Obvious、Triangulation）を試す
- [ ] リファクタリングで設計パターンを適用する

#### 📚 今週（3日）：基本パターンの習得

**初学者向け：**

- [ ] Red-Green-Refactorを10回実践する
- [ ] F.I.R.S.T.原則に従ったテストを作成する
- [ ] 基本的な実装戦略を使い分ける

**実践者向け：**

- [ ] 複雑なビジネスロジックにTDDを適用する
- [ ] テストダブル（Mock、Stub）を活用する
- [ ] CI/CDパイプラインに統合する

#### 🏢 今月（継続的改善）：TDD文化の確立

**チーム全体：**

- [ ] TDD実践基準をチームで統一する
- [ ] コードレビューにTDD観点を追加する
- [ ] 定期的なTDDモブプログラミングを開催する

### TDD成功パターンの可視化

```mermaid
mindmap
  root(("TDD成功の秘訣"))
    ("小さく始める")
      ("1つの振る舞いから")
      ("最小限のテストケース")
      ("完璧主義を排除")
    ("継続的に検証")
      ("毎回のテスト実行")
      ("リファクタリング後の確認")
      ("品質指標の測定")
    ("段階的に改善")
      ("Red→Green→Refactorの厳守")
      ("実装戦略の使い分け")
      ("設計の継続的向上")
    ("価値を測る")
      ("開発速度の向上")
      ("バグ発見率の改善")
      ("コード品質の安定化")
```

## まとめ：TDDで「信頼できるコード」を構築する

### 核心価値の再確認

1. **恐怖の管理**：テストファーストで不安を具体的な行動に変換する
2. **品質中心**：継続的な検証により信頼性を確保する
3. **検証可能な改善**：客観的指標により段階的に技術を向上させる
4. **持続可能な開発**：変化する要求に柔軟に対応する

### 行動への転換

従来の「実装してからテスト」から「テストを書いてから実装」への転換により、真に信頼できるソフトウェアを効率的に開発できます。

**今日から始めましょう。最初のテストは30%の完成度で十分です。失敗することから始まるのがTDDの第一歩です。**

---

## 付録：実践的チェックリストとテンプレート

### 30%テスト作成テンプレート

```javascript
// [機能名]（30%テスト）

describe('[クラス名]', () => {
  it('[期待する振る舞い]', () => {
    // Given: 前提条件（1-2行）
    const target = new [クラス名]();

    // When: 実行（1行）
    const result = target.[メソッド名]([引数]);

    // Then: 検証（1行）
    expect(result).toBe([期待値]);
  });
});

// 実装戦略選択指針：
// - 簡単: Obvious Implementation
// - 少し複雑: Fake It → 段階的一般化
// - 複雑: Triangulation（複数テストケース）
```

### 言語別テストフレームワーク例

```javascript
// JavaScript/TypeScript: Jest, Mocha, Vitest
// Python: pytest, unittest
// Java: JUnit
// C#: NUnit, xUnit
// Ruby: RSpec
// Go: testing package
```

### TDD実践チェックリスト（定量的評価基準）

```yaml
tdd_practice_checklist:
  red_phase:
    - [ ] テストが失敗することを確認する（実行結果Red）
    - [ ] 1つの振る舞いに集中している（単一責任原則）
    - [ ] 実装なしで意図が理解できる（可読性8/10点以上）

  green_phase:
    - [ ] テストが成功することを確認する（実行結果Green）
    - [ ] 最小限の変更で実装されている（差分10行以内）
    - [ ] 実装戦略が適切に選択されている（初心者はFake It推奨）

  refactor_phase:
    - [ ] テストが引き続き成功している（回帰テストをクリア）
    - [ ] コードの重複が除去されている（DRY原則を遵守）
    - [ ] 設計が改善されている（可読性・保守性が向上）

# TDDサイクル時間の目安
cycle_time_allocation:
  red_phase: 5分（テスト作成・失敗確認）
  green_phase: 10分（最小実装・成功確認）
  refactor_phase: 15分（重複除去・設計改善）
  total: 30分以内（1サイクル完了）
```
